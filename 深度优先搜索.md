# 深度优先搜索

* 框架

```c++
void dfs(int deep) {
    if (到达边界) {
      // 做一些处理后返回
    } else {
        for(所有可能的选择) {
            dfs(deep + 1);
        }
    }
}
```

* 迷宫模板

  ```c++
  // 对坐标为(x, y)的点进行搜索
  void dfs(int x, int y) {
      if (x,y) 是终点 {
          方案数增加
          return;
      }
      标记(x, y)已经访问
          // 尝试
      for (x, y) 能到达的格子(tx, ty) {
          if (tx, ty) 没有访问 {
              dfs(tx, ty);
          }
      }
      
      取消(x, y)访问标记
          //　回溯
  }
  ```

  * 回溯一般取决于，是否必须重复经过某一个点
  * 定义一个全局变量可记录最值, 参数传递当前值

* 剪枝

  * 可行性剪枝

    搜索过程中，一旦发现如果某些状态无论如何都不能找到最终的解，就可以将其“剪枝”了。

    如，奇偶性剪枝

  * 最优性剪枝

    如果发现当前的步数已经超过了当前最优解，那从当前状态开始的搜索都是多余的，因为这样搜索下去永远都搜不到更优的解．在搜索是否有可行解的过程中，一旦找到了一组可行解，后面所有的搜索都不必再进行了，这算是最优性剪枝的一个特例

    

    对于某一些特定的搜索方式，一个方案可能会被搜索很多次，这样是没必要的。

    ```c++
    void dfs(int s, int cnt, int pos) {
        ...
        ...
        for (int i = pos; i <= n; i++) {
            if (!xuan[i]) {
                xuan[i] = true;
                dfs(s + a[i], cnt + 1, i + 1); // i + 1 表示从上一次选取的位置后面开始选
                xuan[i] = false;
            }
        }
    }
    ```

    

  # 广度优先搜索

  * 框架

    ```c++
    void bfs(起始点) {
        将起始点放入队列中;
        while (如果队列不为空) {
            访问队列中队首元素x;
            删除队首元素;
            for (x 所有相邻点) {
                if (该点未被访问过且合法) {
                    将该点加入队列末尾;
                }
            }
        }
        队列为空，广搜结束;
    }
    ```

    * 起始点的结构设计
    * 状态访问设计
    * 最短路径记录

































