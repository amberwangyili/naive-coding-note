# 图论



- 图的表示

  ```c++
  #include <map>
  #include <set>
  #include <vector>
  
  vector<vector<int> > G;
  map<int,set<int>> G;
  ```

- `Dijkstra 最短路`

  - `算法流程`

    1. `从V-U中找出一个距离源点最近的顶点v, 将v加入集合U`
    2. `用dist(v)和v连出的边来更新和v相邻的,不在集合U中的顶点dist, 这一步称为松弛操作`
    3. `重复步骤1和2, 直到V=U或找不出一个从s出发有路径到达的顶点`

  - `代码`

    ```c++
    //点结构
    struct node{
        int idx;
        int length;
        bool operator<(const node a) const {
            if(length != a.length){
                return length < a.length;
            } else {
                return idx < a.idx;
            }
        }
    }
    //距离数组
    int dis[];
    
    //访问标记集合
    bool vis[];
    
    //父亲结点
    int father[];
    
    //已访问点集合
    set<node> s;
    
    while(!s.empty()){
        //获取堆顶元素,并将堆顶元素从堆中删除
        set<node>::iterator it = s.begin();
        s.erase(*it);
        u = it->idx;
        if(vis[u]) continue;
        vis[u] = true;
        //进行和普通dijkstra算法类似的松弛操作
        for(auto itt = G[u].begin(); itt!= G[u].end(); itt++){
            int v = *(itt).idx;
            int len = *(itt).length;
            if(!vis[v] && dis[v] > dis[u]+ len){
                s.erase(node(v,dis[v]));
                s.insert(node(v,dis[v]= dis[u]+w));
                fa[v] = u;
            }
        }
    }
    
    
    
    ```

- `SPFA算法`

  - `算法流程`

    1. `初始队列仅包含源点,且源点的dis[s] = 0`
    2. `取出队列头顶点u, 扫描从顶点u出发的每条边,设每条边另一端为v,若dis[u] + <u,v> < dis[v], 则`
       - `将dis[v]修改为dis[u]+<u,v>`
       - `若v不在队列中,则将v入队`
    3. `重复步骤2直到队列为空`
       - `SPFA可以用来判断负环, 在进行SPFA时, 用一个数组cnt来标记每个顶点的入队次数,若一个顶点入队次数cnt大于顶点总数n,则表示该图中包含负环`

  - `代码`

    ```c++
    //距离数组
    int dis[];
    //访问数组
    int vis[];
    //入队次数标记
    int count[];
    
    bool spfa(int u){
        queue<int> q;
        q.push(u);
        dis[u] = 0;
        vis[u] = true;
        count[u] = 1;
        while(!q.empty()){
            int now = q.front();
            q.pop();
            vis[now] = false;
            for(auto it = G[now].begin(); it != G[now].end(); it++){
                int next = *(it).idx;
                int len = *(it).length;
                if(len+dis[now] < dis[next]){
                    dis[next] = len+dis[now];
                    if(!vis[next]){
                        q.push(next);
                        vis[next] = 1;
                        count[next] ++;
                        if(count[next]>n ) return false;
                    }
                }
            }
        }
    	return true;
    }
    
    ```

- `Floyd`

  - `代码`

    ```c++
    vector<vector<int> > G;
    void floyd(itn N){
        for(int k = 1; k <= N; k++){
            for(int i = 1; i<= N; i++){
                for(int j =1 ; j<= N; j++){
                    G[i][j] = min(G[i][j],G[i][k]+G[k][j]);
                }
            }
        }
    }
    ```

    

- `拓扑排序`

  - `算法流程`

    1. `选择一个入度为0的顶点并将它输出`
    2. `删除图中从顶点连出的所有边`
       - `循环结束,若输出的顶点数小于图中的顶点数,则表示图中存在回路`

  - 代码

    ```c++
    int cnt = 0;
    bool topo(){
        int start;
        queue<int> q;
        for(int i = 0; i<n; i++){
            if(indegree[i] == 0){
                start = i;
                q.push(start);
                cnt ++;
            }
        }
        while(!q.empty()){
            int now = q.front();
            q.pop();
            for(auto it = G[now].begin(); it != G[now].end(); it++){
                int neightbor = *(it);
                indegree[neighbor]--;
                if(indegree[neighbor] == 0){
                    q.push(neighbor);
                    cnt ++;
                }
            }
        }
        return cnt == n;
    }
    ```

- `欧拉回路`

  - `如果图G中存在这样一条路径, 使得它恰好通过G中每条边一次,则称该路径为欧拉路径, 若这条路径是一个环路,则成为欧拉回路`

  - **无向图**

    - `无向图存在欧拉路径当且仅当无向图G是连通图,且图中有两个奇度顶点或者无奇度顶点`

    - `当无向图G是包含两个奇度顶点的连通图时,G的欧拉路径必定以这两个奇度顶点为端点`

    - `一个无向图存在欧拉回路当且仅当无向图G连通且不存在奇度顶点`

      ```c++
      //判断连通`
      bool bfs(){
          queue<int> q;
          q.push(1);
          
          while(!q.empty()){
          int now = q.front();
          q.pop();
          vis.insert(now);
      		 for(auto it = G[now].begin(); it!= G[now].end(); it++){
                   int neighbor = (*it);
                   if(!vis.count(neighbor)){
                        q.push(neighbor);
                  }
              }
          }
          return vis.size() == N;
      }
      void euler(){
          int cntodd = 0;
          for(int i = 1; i<= n ; i++){
              if(degree[i]%2==1){
                  cntodd ++ ;
              }
          }
          if(cntodd==0){
              cout << "It has an euler circuit"<<endl;
          } else if(cntodd == 2){
              cout << "It has an euler path!" <<endl;
          } else {
              cout << "It doesn't have an euler path!"<<endl;
          }
      }
      ```

      

  - **有向图**

    - `有向图存在欧拉路径当且仅当G是弱连通的有向图,且满足以下两个条件之一`

      - `所有顶点的入度与出度相等`
      - `有一个顶点出度与入度之差为1, 一个顶点出度与入度之差为-1, 其余顶点的出度入度相等`

    - `有向图G包含两个入度和出度不相同的顶点且有欧拉路径时,欧拉路径必定以这两个入度出度不相同的顶点为端点`

    - `有向图G存在欧拉回路当且仅当G是连通的有向图,且所有顶点的入度与出度相等`

      ```c++
      int euler(){
          int first = 0, last = 0;
          for(int i = 1; i<=n ; i++){
              if(degree[i]<-1||degree[i]>1){
                  cout << "It doesn't have an euler path!" << endl;
                  return 0;
              } else if(degree[i]==-1){
                  if(first !=0){
                      cout << "It doesn't have an euler path!" << endl;
                      return 0;
                  } else {
                      first = i;
                  }
              } else if(degree[i]==1){
                  if(last !=0){
                      cout << "It doesn't have an euler path!" << endl;
                      return 0;
                  } else {
                      last = i;
                  }
              }
          }
          if(first == 0 && last ==0){
              cout << "It has an euler circuit!"<<endl;
              return 1;
          } else if(first!= 0&& last != 0){
      		cout << "It has an euler path!" << endl;
              return first;
          }
      }
      ```

      

  - `找到欧拉回路`

    ```c++
    stack<int> path;
    void dfs(int u ){
        set<int> all_nexts = G[u];
        for(auto it = all_nexts.begin(); it != all_nexts.end(); it++){
            int next = *(it);
            auto it2 = G[u].find(next);
            if(it2!=G[u].end()){
                graph[u].erase(it2);
                dfs(next);
            }
        }
    }
    
    void euler_find(){
        int start = 1;
        dfs(start);
        while(!path.empty()){
            cout << path.top() << endl;
            path.pop();
        }
    }
    ```

- `并查集`

  ```c++
  void init(){
      for(int i =0; i< N; i++){
          fa[i] = i;
      }
  }
  int get(int x){
      if(x!=fa[x]){
          fa[x] = get(fa[x]);
      }
      return fa[x];
  }
  
  bool merge(int x, int y){
      int fx = get(x);
      int fy = get(y);
      if(fx!=fy){
          fa[fx] = fy;
          return 1;
      }
      return 0;
  }
  ```

  

# 状态压缩动态规划



* `二进制枚举`

  `每个i,要或者不要`

  ```c++
  for(int i = 0; i < (1<<n); i++){
      for(int j = 0; j<n; j++){
          if(i&(1<<j)){
             //第j个人属于集合 
          }
      }
  }
  ```

* `旅行商问题`

  `dp[S][i]为访问城市集合为S,当前在城市i的最短长度, 则d[S][i] = min(d[S-{i}][j]+dist[j,i])`

  ```c
  memset(dp,0x7fffffff,sizeof(dp));
  dp[1][0] = 0;
  for(int s = 0; s <(1<<n); s++){
      for(int i = 0; i<n; i++){
          if(s&(1<<i)){
              for(int j = 0; j<n; j++){
                  if(j!=i&&(s&(1<<j))){
                      dp[s][i] = min(dp[s][i],dp[s^1<<i][j]+dist[j][i]);
                  }
              }
          }
      }
  }
  int ans = 0x7fffffff;
  for(int i = 1; i<n; i++){
      ans = min(ans,dp[(1<<n)-1][i]+dist[i][0]);
  }
  ```

* `stage模板` 

  * `题目描述`: `给定一个n*m的矩阵,行数和列数都不超过20,其中有些格子可以选,有些格子不能选,现在你需要从中选出尽可能多的格子,且保证选出的所有格子直接不相邻`

    * `定义辅助数组`

      ```c++
      int state[20+1]; //将(i,j)格子的状态放入state[i]中,state[i]表示第i行可选格子组成的集合
      for(int i = 1; i<= n; ++i ){
          for(int j = 0 ; j<m ; ++j){
              int flag;
              cin >> flag;
              state[i] |= (1<<j)*flag;
          }
      }
      int dp[20+1][1<<20];
      ```

  * `状态转移方程`

    * `定义:当前放到第几行,当前行的选择方案`
    * `dp[i,j] = max(dp[i][j], dp[i-1][k]+cnt), k表示上一行的状态, cnt为j状态选择的格子数`

  * `代码 `

    ```c++
    bool ok(int x){
        //行内是否自己相交
        return (x&(x/2)) == 0;
    }
    bool fit(int now, int flag){
        return (now|flag) == flag;
    }
    int count(int now){
        int s = 0; //统计now的二进制形式中有多少个i
        while(now){
            s += (now&1); //判断now二进制的最后一位是否为1,如果是则累加
            now >>= 1; //now右移一位
        }
        return s;
    }
    bool not_intersect(int now, int prev){
        return (now&prev) == 0;
    }
    for(int i = 1; i<=n ; ++i){
        for(int j = 0; j<(1<<m); ++j){
            //枚举当前行的状态
            if(!ok(j)||!fit(j,state[i])){
                //如果当前行状态不合法则不执行后面的枚举
        	}
            int cnt = count(j); //统计当前行一共选了多少个格子
            for(int k = 0; k <(1<<m); ++k){
                if(ok(k)&&fit(k,state[i-1])&&not_intersect(j,k)){
                    //判断前一行是否合法和当前行和前一行的方案是否冲突
                    dp[i][j] = max(dp[i][j], dp[i-1][k]+cnt); 
                    //更新当前行,当前状态的最优解
                }
            }
    
        }
    }
    int ans = 0; //保存最终答案
    for(int i = 0; i<(1<<m); ++i){
        ans = max(ans,dp[n][i]); //枚举所有状态,更新最大值
    }
    cout << ans << endl;
    
    
    ```

    

  

# 基础数论

* `gcd & lcm`

  ```c++
  #include <algorithm>
  
  int lcm(int a, int b){
      return a/__gcd(a,b)*b;
  }
  ```

* `prime`

  ```c++
  bool is_prime(int n){
      if(n==1){
          return false;
      } 
      for(int i = 2; i*i<n; i++){
          if(n%i==0){
              return false;
          } 
      }
      return true;
  }
  
  bool is_prime[N+1];
  for(int i = 2; i<= n; i++){
      is_prime[i] = true;
  }
  for(int i = 2; i<=n ; i++){
      if(is_prime[i]){
          for(int j = i*i; j<=n; j+=i){
              is_prime[j] = false;
          }
      }
  }
  ```

* `euler` `小于等于n的所有数中与n互质的数的个数`

  * `公式`
    $$
    \phi(x) = x(1-\frac{1}{p_1})(1-\frac{1}{p_2})\cdots(1-\frac{1}{p_n})
    $$

  * `欧拉定理`

    `若a,n互质,则有`

  $$
  a^{\phi(n)} = 1\mod n\\
  a^{p-1} = 1 \,, \text{ p is prime}
  $$

  * `求一个数的欧拉函数值`

    ```c
    int res = n;
    for(int i = 2; i*i <= n; ++i){
        if(n%i==0){
            res = res/i*(i-1);
            while(n%i==0){
                n/=i;
            }
        }
    }
    if(n>1){
        res = res/n*(n-1);
    }
    cout << res << endl;
    ```

  * `区间预处理欧拉函数`

    ```c 
    for(int i = 1; i<=n; i++){
        phi[i] = i;
    }
    for(int i = 2; i<=n; i++){
        if(phi[i] == i){
            for(int j = i; j<=n; j+= i){
                phi[j] = phi[j]/i * (i-1);
            }
        }
    }
    ```

    

* `matrix `

  * `矩阵乘法`

    ```c
    struct matrix {
        int n , m;
        int a[100][100];
    };
    matrix matrix_mul(matrix A, matrix B){
        matrix C;
        C.n = A.n;
        C.m = B.m;
        for(int i = 0; i< A.n; i++){
            for(int j = 0; j< B.m; j++){
                C.a[i][j]  = 0;
                for(int k = 0; k<A.m; ++k){
                    C.a[i][j] += A.a[i][k]*B.a[k][j];
                }
            }
        }
        return C;
    }
    ```

    

  * `矩阵二分幂`

    ```c++
    matrix unit(){
        matrix res;
        for(int i = 0; i< n; ++i){
            for(int j = 0; j<n; ++j){
                if(i==j){
                    res.a[i][j] = 1;
                } else {
                    res.a[i][j] = 0;
                }
            }
        }
        return res;
    }
    
    matrix matrix_pow(matrix A, int n, int mod){
        //快速求矩阵A的n次方
        matrix res = unit(), temp = A;
        for(;n;n/=2){
            if(n&1){
                res = matrix_mul(res,temp,mod);
            }
            temp = matrix_mul(temp,temp,mod);
        }
        return res;
    }
    ```

    

# 二分法



* `二分查找`

  ```c
  int binary_search(int x){
      int l = 0, r = n-1;
      while(l<=r){
          int mid = (l+r)>>1;
          if(a[mid] == x){
              return mid;
          }
          if(a[mid] < x){
              l = mid + 1;
          } else {
              r = mid - 1;
          }
      }
      return -1;
  }
  double cal(double y){
      if(f(l)>y || f(r)<y){
          return -1;
      }
      while(r-l>eps){
          double mid = (l+r)/2;
          if(f(mid)>y){
              r = mid;
          } else {
              l = mid;
          }
      }
      return l;
  }
  ```

* `二分快速幂`

  ```c++
  int pow(int x, int y, int p){
      if(!y){
          return 1;
      }
      int res = pow(x,y/2,p);
      res = res * res %p;
      if(y&1){
          res = res * x %p;
      }
      return res;
  }
  
  int pow(int x, int y , int p){
      int res = 1;
      while(y){
          if(y&1){
              res = res * x % p;
          }
          y>>=1;
          x = x * x % p;
      }
      return res;
  }
  ```

  

* `二分答案`

  ```c++
  bool check(int x){}
  int cal(int l , int r){
      while(l<r){
          int mid = (l+r)>>1;
          if(check(mid)){
              r = mid;
          } else {
              l = mid + 1;
          }
      }
      return l;
  }
  ```

  

* `01分数规划`

  * `给出n个物品,每个物品有两个属性a和b,选择k个元素, 请问选择k个元素的sum(a)/sum(b)最大值多少`

  * `代码`

    ```c++
    double g(double v){
        for(int i = 0; i< n; ++i){
            tmp[i] = a[i]-v*b[i];
        }
        sort(tmp,tmp+n);
        double sum = 0;
        for(int i = n -k; i<n; i++){
            sum += tmp[i];
        }
        return sum;
    }
    
    
    double cal(){
        double l = 0, r = 1e10;
        while(r-l>eps){
            double mid = (l+r)/2;
            if(g(mid) > 0){
                l = mid;
            } else {
                r = mid;
            }
        }
        return l;
    }
    ```

* `三分法`

  ```c++
  double cal(int l, int r){ //求极大值
      while(r-l>eps){
          double mid = (l+r)/2;
          double mmid = (mid+r)/2;
          if(f(mid)<f(mmid)){
              l = mid;
          } else {
              r = mmid;
          }
      }
      return l;
  }
  ```

## 动态规划优化

* `区间动态规划`

  * `对于区间DP这一类问题,我们需要计算区间[1,n]的答案,通常用一个二维数组dp表示, 其中dp[x] [y] 表示区间[x,y]`

  * `常见转移`
    $$
    dp[l][r] \leftarrow dp[l][r-1], dp[l+1][r]\\
    dp[l][r] \leftarrow dp[l][k],dp[k+1][r], \forall\  l\le k  < r
    $$

  * `方法: 对于长度为n的区间DP,我们可以先计算[1,1],[2,2],[n,n]的答案,再计算[1,2].[2,3],..,[n-1,n],以此类推,直到得到原问题的答案.`

  * `循环结构`

    ```c++
    for(int l = 2; l <= n; ++l){
        for(int i = 1, j; i<=n-l+1; ++i){
            j = i+l-1;
            for(int k = i; k < j; ++k){
               
            }
            
        }
    }
    ```

    

```c++
void print_fway(int l , int r){ //前序遍历
    if(l>r) return ;
    cout << root[l][r];
    print_fway(l,root[l][r]-1);
    print_fway(root[l][r]+1,r);
}
int main(){
    cin >> n;
    for(int i = 1; i<=n; i++){
        cin >> a[i];
        dp[i][i] = a[i];
        root[i][i] = i;
    }
    
    for(int l = 2; l<=n; l++){
        for(int i =1, j; i<= n-l+1; i++){
            j = i+l-1;
            for(int k = i+1; k<j; k++){
                if(dp[i][k-1]*dp[k+1][j]+a[k]>dp[i][j]){
                     dp[i][j] = dp[i][k-1]*dp[k+1][j]+a[k];
                			root[i][j] = k;
                }
            }
            if(dp[i+1][j]+a[i] > dp[i][j]){
                dp[i][j] = dp[i+1][j]+a[i];
                root[i][j] = i;
            }
            if(dp[i][j-1]+a[j]>dp[i][j]){
                dp[i][j] = dp[i][j-1] + a[j];
                root[i][j] = j;
            }
        }
    }
    cout << dp[1][n]<<endl;
    print_fway(1,n);
			return 0;
}
```

